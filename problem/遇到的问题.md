###布局
* 问题一：
	* 当前元素如果要设置float=left，则为了防止其父元素的高度塌陷，父元素要设置overflow=hidden
	* 但是在这种情况下当前元素的子元素的高度也就固定了，就会出现显示问题

	* 解决：
		* 再设置一个当前元素的父元素的同辈元素，开启元素定位，把它定位到想要放置的位置

* 问题二：
	* 开启元素定位时，如果是相对定位，元素不能脱离文档流，如果属性设置位从隐藏到显示，则会挤开它下面的元素，打乱布局

	* 解决：
		* 可以开启绝对定位，使元素脱离文档流，但是它的父元素要开启相对定位

###js
* 问题一：
	* 如果复选框绑定的是onchange事件，复选框被选中后在点击加或减按钮总计不会改变

	* 解决：
		* 在加和减按钮的点击事件中都对checkbox的checked属性进行判断
		* 如果选中了就重新计算总价与总数量，在重新写到对应的元素对象中

* 问题二：
	* childNodes
	* previousSibling
	* nextSibling
	* 如果使用以上的方法查找元素节点，它会收到空字符的干扰
	* 在新插入商品后，元素之间没有字符，使用以上的方法找不到想要的元素

	* 解决：
		* 可以使用querySelector("css")按照指定的条件查找元素对象

* 问题三：
	* 选中后，单项删除商品，总计不会修改

	* 解决：
		* 在单项删除的方法中再次获取总计中的总数和总价，减去要删除项的input中的数量和价格的小计

* 问题四:
	* inputChange()函数有问题，如果始终修改同一个input不会出错，而修改不同的input元素就会出错
	* 这是由于闭包的原因造成的，每个input只绑定了onchange事件，而m的值只有一个，调用的时候其值可能与当前的商品数量对应不上
	* 因此造成了数据不正确

	* 解决方法试验:
		* 声明一个数组，不遍历class=input组成的数组inputs，而是遍历所有的tagName=tr组成的数组trs
		* 遍历trs，判断当前tr是否包含class=input的元素，如果包含，数组压入input元素的值，input元素绑定onchange事件，否则压入0
		* 这样一来m就保存了多个值
		* 每当调用onchange事件的时候
			* this.parentNode.parentNode是当前元素的tr元素
			* 根据this.parentNode.parentNode.rowIndex获取当前tr的索引
			* 根据索引取出对应的值，为m[this.parentNode.parentNode.rowIndex]，这样是否能解决

	* 结论:
		* 可以解决上述问题